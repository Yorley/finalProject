
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package project;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import project.semantic.evaluators.*;
import project.semantic.SemanticStack;
import project.semantic.SymbolTable.SymbolTable;

import project.semantic.registers.*;
import project.semantic.Writer;

parser code {:

    public  ArrayList<String> expectedTokens_msg = new ArrayList<String>();
    public  ArrayList<String> errorsLines = new ArrayList<String>();
    public  ArrayList<String> errors = new ArrayList<String>();
    public  ArrayList<String> getExpectedTokens() {
        return expectedTokens_msg;
    }

    public ArrayList<String> getLineErrors() {
        return errorsLines;
    }
    public ArrayList<String> getErrors() {
        return errors;
    }

    protected void report_expected_token_ids() {

        List<Integer> ids = expected_token_ids();
        LinkedList<String> list = new LinkedList<String>();

        for (Integer expected : ids) {
            if (!(symbl_name_from_id(expected).equals("EOF") || symbl_name_from_id(expected).equals("error")))
                list.add(symbl_name_from_id(expected));
          }
        String msg = "expected tokens are "+ list;
        expectedTokens_msg.add(msg);
        System.err.println(msg);  
    }
    
    public void syntax_error(Symbol s){
        String msg = "Syntax error: "+" Line: " + s.left +" Column: " +s.right;
        String symbolName = symbl_name_from_id(s.sym);
        msg += "\nCurrent: " + symbolName + "\n";

        errorsLines.add(msg);
        System.err.print(msg);
      
        report_expected_token_ids();
    }
    
    public void unrecovered_syntax_error(Symbol s)throws java.lang.Exception{   
        
    }

    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {

        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                m.append(" in line " + (s.left+1));
                if (s.right >= 0)
                    m.append(", column " + (s.right));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }
    public void printError(String pMsg){
        System.err.println(pMsg+"\n");
        errors.add(pMsg+"\n");        
    }

    public void report_fatal_error(String message, Object info) {

        //report_error(message, info);
        //System.exit(1);
    }


:}   
//Todos los simbolos terminales aquí declarados son necesarios para las declaraciones de cada estuctura; si alguno de ellos no está pro se utiliza en alguna parte, esto dará error.
// Simbolos terminales
terminal LITERAL_NUM,LITERAL_CONSTANT, LITERAL_CHAR, TYPE_NUM, TYPE_CHAR, TYPE_STR, IF, ELSE, WHILE,BREAK, KEYWORD, 
    IDENTIFIER, ARITHMETIC, SEMICOLON, COMMA, LPAR, RPAR, ASSIGN,PUTW, PUTS, MAIN, OPERADOR, BEGIN, END, PLUS,MINUS,MULT,DIV,
    AND, OR, HIGHER, LOWER,EQUALS,DIFFERENT,RETURN,COLON,SWITCH,CASE,DEFAULT;


//Todos los no terminales, son las "funciones" que se utilizan para definir una estructura, deben estar declaradas para que no surja ningún error.
// Simbolos no terminales
non terminal program,main,decl_set, variables_list, variables_decl_aux , aux_variable_list, constant_list, mainn, fin, mainnn,mainnnn
             ,lmain, variables_list_one, assign,assign_one,variables_elem,variables_elem_one,variables_elem_two, variables_elem_three
            ,end_decl,decl_set_aux, variables_list_auxx,assign_two,content,if_struct,while_struct,declar_assign,putw_struct,puts_struct,structures,
            puts_struct_one,puts_struct_two,puts_struct_three,puts_struct_fourth            
            ,putw_struct_one,putw_struct_two,putw_struct_three,putw_struct_fourth,
            arithmetic,add ,subs, mult, div, params,_aux,if_struct_one,if_struct_two,if_struct_three,if_struct_four,if_struct_five,else_struct,
            condition,else_struct_one,else_struct_two,else_struct_three,declar_assign_one,declar_assign_two,declar_assign_three,
            comparison,expr,expr_two,expr_aux,logic_comparison,exp,arithmetic_aux,expr_aux_one,condition_one,arithmetic_aux_one,
            if_struct_six,condition_two,condition_three,condition_aux,expr_one, expr_three, expr_four, while_struct_one,while_struct_two,
            while_struct_three,while_struct_four,while_struct_five,while_struct_six,while_struct_aux,
            init_decl, funct,funct_sec,funct_third,funct_fourth,funct_fifth,funct_sixth,parameters, primitiveType,init_decl_one,
            funct_seventh, case_stms, switch,  switch_one, switch_two, switch_three,  switch_four,  switch_five,switch_nine,
            switch_seven,switch_eight , case_structures, switch_six,case, case_one, case_two, case_three, case_content,case_four
            ;

// Seccion de precedencia


//Gramatica

start with program;
// Simbolo Inicial
 
//Estructura que me indica como debe comenzar el programa, en esta estructura hay más donde se utilizan para ir recuperando errores.   
program ::= variables_list:d lmain:f | lmain:f;

lmain ::= MAIN main | error {: printError("Missing main token") ;:} main;



//En esta estructura se tiene la forma en que se debe declarar una variable, para ello se utilizan diferentes etiquetas que declara cuál terminal debe ir en la estructura y si esta no está recupera el error.
variables_list ::= variables_elem variables_list | variables_elem ;

variables_elem ::= TYPE_NUM:t {:
                                    Symbol symbolT= new Symbol(0,tleft,tright,t);
                                    SR_Type type= new SR_Type (symbolT);
                                    type.setType(sym.TYPE_NUM);
                                    SemanticStack.getInstance().push(type);
                              :} 
                    variables_elem_one ;
                   //| error {: printError("Missing Type token") ;:} variables_elem_one  ;

variables_elem_one ::= IDENTIFIER:id {: Symbol symbolID= new Symbol(sym.IDENTIFIER,idleft,idright,id);
                                      SR_ID register= new SR_ID(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :}  variables_elem_two
                       | error {: printError("Missing Type token") ;:} variables_elem_two  ;

variables_elem_two ::= SEMICOLON  {:VariableEvaluator.getInstance().evalUn();:}
                        | assign
                        | error {: printError("Missing ; token") ;:} ;
end_decl ::= SEMICOLON 
                        | error {: printError("Missing ; token") ;:} ;

//Cada vez que se realiza una asignación debe tener el simbolo = y un entero junto con ;, para esta estructura se defien varias etiquetas para la recuperación de errores.
assign ::= ASSIGN assign_one | error {: printError("Missing = token") ;:} assign_one;

assign_one ::= LITERAL_NUM:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID,"int");
                                      SemanticStack.getInstance().push(register);
                                   :}  assign_two 
                
;
                

assign_two ::= SEMICOLON {:VariableEvaluator.getInstance().evalIn();:};
               


//El main del programa debe seguir cierto orden en la estructura, para ell se utilizan diferntes etiiquetas para declarar la estructura del main.
main ::= LPAR  mainn
        |error {: printError("Missing ( token") ;:} mainn;

mainn ::= RPAR mainnn
        | error {: printError("Missing ) token") ;:} mainnn; 

mainnn ::= BEGIN mainnnn
        | error {: printError("Missing { token") ;:} mainnnn; 

mainnnn ::=  content END | END 
        | error {: printError("Missing } token") ;:} fin; 

fin ::=  END
        | error {: printError("Missing } token") ;:};

//Content es la estructura que me dice como debe ser el contenido del programa, dentro de esta estructura pueden haber if,else,while, puts,putw, asignaciones...
content ::= structures content | structures ;

//Definición  de las estructuras if, putw,puts,while y la declaración de una asignación.
structures ::= if_struct | putw_struct | puts_struct| while_struct | declar_assign | funct | switch;

//Estructura para declarar como debe ser el putw, en ella se llaman una secuencia de etiquetas para ir recuperando errores.
putw_struct ::= PUTW:p {:
                           Symbol symbol= new Symbol(sym.PUTS,pleft,pright,p);
                           SR_PUTW register= new SR_PUTW(symbol);
                           SemanticStack.getInstance().push(register);
                    :} putw_struct_one;
putw_struct_one ::= LPAR putw_struct_two| error {: printError("Missing } token") ;:} putw_struct_two;
putw_struct_two ::= arithmetic putw_struct_three 
                    | IDENTIFIER:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_ID register= new SR_ID(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :}  putw_struct_three 
                    | LITERAL_NUM :id {: Symbol symbolDO= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolDO,"int");
                                      SemanticStack.getInstance().push(register);
                                   :} 
                      putw_struct_three | error {: printError("Missing } token") ;:} putw_struct_three;
putw_struct_three ::= RPAR putw_struct_fourth {: RWEvaluator.getInstance().evalPutw(); :}| error {: printError("Missing } token") ;:} putw_struct_fourth; 
putw_struct_fourth ::= SEMICOLON| error {: printError("Missing ; token") ;:} SEMICOLON;

//Estructura para declarar como debe ser el puts, en ella se llaman una secuencia de etiquetas para ir recuperando errores.
puts_struct ::= PUTS:p {:
                           Symbol symbol= new Symbol(sym.PUTS,pleft,pright,p);
                           SR_PUTS register= new SR_PUTS(symbol);
                           SemanticStack.getInstance().push(register);
                        :} puts_struct_one ;
puts_struct_one ::= LPAR puts_struct_two | error {: printError("Missing } token") ;:} puts_struct_two;
puts_struct_two ::= LITERAL_CONSTANT:s {:
                                            Symbol symbol= new Symbol(0,sleft,sright,s);
                                            SR_DO sr_do = new SR_DO(symbol,"char");
                                            SemanticStack.getInstance().push(sr_do);
                                            :} puts_struct_three 
                    | error {: printError("Missing } token") ;:} puts_struct_three;
puts_struct_three ::= RPAR puts_struct_fourth {: RWEvaluator.getInstance().evalPuts(); :} | error {: printError("Missing ; token") ;:} puts_struct_fourth;
puts_struct_fourth ::= SEMICOLON | error {: printError("Missing ; token") ;:} SEMICOLON;


//Estructura para declarar como deben ser las operaciones aritmeticas, en ella se llaman una secuencia de etiquetas para ir recuperando errores.
arithmetic ::= add |subs|mult |div ;//| error {: printError("Missing ) token"); :};
mult ::= params MULT:ar
                    {:Symbol symbol= new Symbol(0,arleft,arright,ar);
                      SR_Op register= new SR_Op (symbol);
                      SemanticStack.getInstance().push(register);
                    :}
         _aux;
div ::= params DIV:ar
                    {:Symbol symbol= new Symbol(0,arleft,arright,ar);
                      SR_Op register= new SR_Op (symbol);
                      SemanticStack.getInstance().push(register);
                    :}
         _aux;
add ::= params PLUS:ar
                    {:Symbol symbol= new Symbol(0,arleft,arright,ar);
                      SR_Op register= new SR_Op (symbol);
                      SemanticStack.getInstance().push(register);
                    :} 
        _aux;
subs ::= params MINUS:ar
                    {:Symbol symbol= new Symbol(0,arleft,arright,ar);
                      SR_Op register= new SR_Op (symbol);
                      SemanticStack.getInstance().push(register);
                    :} 
                _aux;


_aux ::= arithmetic | params ;

//Obliga al programa a tener enteros o una variable.
params ::= LITERAL_NUM:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID,"int");
                                      SemanticStack.getInstance().push(register);
                                   :} 
            | IDENTIFIER:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :}
            | error {: printError("Missing parameter token") ;:};



//La estructura del if me indica como debe ser la sintaxis en el programa, para ello se realizan diferentes etiquetas donde en cada una se dice cuál es el simbolo que debe haber y realiza la recuperacion de errores.
if_struct ::= IF:iff 
              {: Symbol symbol = new Symbol(0,iffleft,iffright,iff);
                 SR_If register = new SR_If(symbol);
                 SemanticStack.getInstance().push(register);
              :} 
              if_struct_one | error {: printError("Missing if token") ;:} if_struct_one;
if_struct_one ::= LPAR if_struct_two ;
if_struct_two ::= condition:c
                   
                 if_struct_three ; //| error {: printError("Missing ( token") ;:} if_struct_three;
if_struct_three ::= RPAR if_struct_four;
if_struct_four ::= BEGIN if_struct_five | error {: printError("Missing { token") ;:} if_struct_five; 
if_struct_five ::= content if_struct_six | error {: printError("Missing ( token") ;:} if_struct_six;
if_struct_six ::= END | END else_struct;





//La estructura del else me indica como debe ser la sintaxis en el programa, para ello se realizan diferentes etiquetas donde en cada una se dice cuál es el simbolo que debe haber y realiza la recuperacion de errores.
else_struct ::= ELSE else_struct_one ;//| error {: printError("Missing if token") ;:} else_struct_one;
else_struct_one ::= BEGIN else_struct_two | error {: printError("Missing if token") ;:} else_struct_two;
else_struct_two ::= content else_struct_three | error {: printError("Missing if token") ;:} else_struct_three;
else_struct_three ::= END;

//En las estructuras if,while debe haber una condición; en esta etiquita declara la sintaxis de las condiciones.Llama diferentes etiquetas para determinar los simbolos que deben ir en esta estructura y realiza recuperación dee errores.
condition ::= condition_aux | exp ;
condition_aux ::= condition_one | error {: printError("Missing if token") ;:};
condition_one ::= LITERAL_NUM:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID,"int");
                                      SemanticStack.getInstance().push(register);
                                   :} condition_two  
                  | IDENTIFIER:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :} condition_two  
                  | arithmetic_aux condition_two | error {: printError("Missing literal_num or Idendifier or arithmetic expression token") ;:} condition_two;
condition_two ::= comparison

                 condition_three ;//;| error {: printError("Missing ) token"); :} condition_three ;
condition_three ::= LITERAL_NUM:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID,"int");
                                      SemanticStack.getInstance().push(register);
                                   :}
                    | IDENTIFIER:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :} 
                    | arithmetic_aux | error {: printError("Missing ) token"); :};
arithmetic_aux ::= LPAR  arithmetic arithmetic_aux_one;// | error {: printError("Missing ) token"); :} arithmetic arithmetic_aux_one;
arithmetic_aux_one ::=  RPAR | error {: printError("Missing ) token"); :} RPAR;

//En cada condición se puede tener una expresión para realizar una comparación, estas se pueden realizar con operadores relacionales o operadores lógicos.
exp ::= LPAR expr ;
expr ::= condition_aux expr_one ;
expr_one ::= RPAR expr_two | RPAR;
expr_two ::= logic_comparison expr_three;
expr_three ::= exp  ;
comparison ::= LOWER:ar 
               {:
                    Symbol symbol= new Symbol(0,arleft,arright,ar);
                    SR_Op register= new SR_Op(symbol);
                    SemanticStack.getInstance().push(register);
               :} 
                | HIGHER:ar {:
                    Symbol symbol= new Symbol(0,arleft,arright,ar);
                    SR_Op register= new SR_Op(symbol);
                    SemanticStack.getInstance().push(register);
               :}
                | EQUALS:ar {:
                    Symbol symbol= new Symbol(0,arleft,arright,ar);
                    SR_Op register= new SR_Op(symbol);
                    SemanticStack.getInstance().push(register);
               :}
                | DIFFERENT:ar {:
                    Symbol symbol= new Symbol(0,arleft,arright,ar);
                    SR_Op register= new SR_Op(symbol);
                    SemanticStack.getInstance().push(register);
               :} ;
logic_comparison ::= AND:ar{:
                    Symbol symbol= new Symbol(0,arleft,arright,ar);
                    SR_Op register= new SR_Op(symbol);
                    SemanticStack.getInstance().push(register);
               :} 
                    | OR:ar {:
                    Symbol symbol= new Symbol(0,arleft,arright,ar);
                    SR_Op register= new SR_Op(symbol);
                    SemanticStack.getInstance().push(register);
               :};


declar_assign ::= IDENTIFIER:id {: Symbol symbolID= new Symbol(sym.IDENTIFIER,idleft,idright,id);
                                      SR_ID register= new SR_ID(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :}  declar_assign_one;
declar_assign_one ::= ASSIGN declar_assign_two | error {: printError("Missing ) token"); :} declar_assign_two;
declar_assign_two ::= IDENTIFIER:id {: Symbol symbolID= new Symbol(0,idleft,idright,id);
                                      SR_ID register= new SR_ID(symbolID);
                                      SemanticStack.getInstance().push(register);
                                   :}  declar_assign_three 
                      | arithmetic declar_assign_three 
                      | LITERAL_NUM:id {: Symbol symbolID= new Symbol(sym.LITERAL_NUM,idleft,idright,id);
                                      SR_DO register= new SR_DO(symbolID,"int");
                                      SemanticStack.getInstance().push(register);
                                   :}  declar_assign_three
                      
                      | error declar_assign_three;
declar_assign_three ::= SEMICOLON {:VariableEvaluator.getInstance().evalAssign();:} | error {: printError("Missing ; token") ;:} SEMICOLON;


//La estructura while dice la sintaxis en el programa, para ello se llaman diferentes etiquetas que permite la recuperación de errores.
while_struct ::= WHILE while_struct_one ;
while_struct_one ::= LPAR while_struct_two | error {: printError("Missing ) token"); :} while_struct_two ;
while_struct_two ::= condition while_struct_three;
while_struct_three ::= RPAR while_struct_four | error {: printError("Missing ) token"); :} while_struct_four;
while_struct_four ::= BEGIN while_struct_five | error {: printError("Missing { token"); :} while_struct_five;
while_struct_five ::= while_struct_aux while_struct_six;
while_struct_aux ::= content | content BREAK SEMICOLON | BREAK SEMICOLON | BREAK SEMICOLON content;
while_struct_six ::= END ;


funct ::= init_decl funct_sec
         
    ;

funct_sec ::= LPAR funct_third
    | error {:printError("Missing ( token");:} funct_third
    ; 

funct_third ::= RPAR funct_fourth   
    | parameters RPAR funct_fourth
    | error {:printError("Missing ) token");:} RPAR funct_fourth
    ;

funct_fourth ::= BEGIN funct_fifth
               | error {:printError("Missing { token");:} funct_fifth;
funct_fifth ::= content funct_sixth
               | funct_sixth
;

funct_sixth ::= RETURN funct_seventh
                ;
funct_seventh ::= LITERAL_NUM END
                | IDENTIFIER:id
                {:
                    Symbol symbol = new Symbol(sym.IDENTIFIER,idleft,idright,id);
                    SR_ID srId = new SR_ID(symbol);
                    SemanticStack.getInstance().push(srId);
                    VariableEvaluator.getInstance().Exist();
               :} END

                | error END
;
init_decl ::=  TYPE_NUM error

             |TYPE_NUM:val init_decl_one
    {: 
        Symbol symbolID = new Symbol(0,valleft,valright,val);
        SR_Type type = new SR_Type(symbolID);
        type.setType(sym.TYPE_NUM);
        SemanticStack.getInstance().push(type); 
        
        
    :} 
    
    | error  {: printError("Type not specified"); :} init_decl_one
    ;
init_decl_one ::= IDENTIFIER:id 
                {:
                    Symbol symbol = new Symbol(sym.IDENTIFIER,idleft,idright,id);
                    SR_ID srId = new SR_ID(symbol);
                    SemanticStack.getInstance().push(srId);
                :}
                //|error  {: printError("Debe traer nombre la funcion"); :}
;
parameters ::= primitiveType IDENTIFIER:id
               {:
               Symbol symbol = new Symbol(sym.IDENTIFIER,idleft,idright,id);
               SR_ID srId = new SR_ID(symbol);
               SemanticStack.getInstance().push(srId);

               VariableEvaluator.getInstance().evalUn();
               :}
               | primitiveType IDENTIFIER:id
                {:
                    Symbol symbol = new Symbol(sym.IDENTIFIER,idleft,idright,id);
                    SR_ID srId = new SR_ID(symbol);
                    SemanticStack.getInstance().push(srId);
                    VariableEvaluator.getInstance().evalUn();
               :}
                 COMMA parameters;
primitiveType ::= TYPE_NUM:val 
                   {:
                        Symbol symbolID= new Symbol(0,valleft,valright,val);
                        SR_Type type= new SR_Type(symbolID);
                        type.setType(sym.TYPE_NUM);
                        SemanticStack.getInstance().push(type);

                   :}
                  //| TYPE_CHAR
;
switch ::= SWITCH switch_one ;
switch_one ::= LPAR switch_two |error  {: printError("Missing ( token"); :}switch_two;
switch_two ::= IDENTIFIER:id
                {:
                    Symbol symbol = new Symbol(sym.IDENTIFIER,idleft,idright,id);
                    SR_ID srId = new SR_ID(symbol);
                    SemanticStack.getInstance().push(srId);
                    VariableEvaluator.getInstance().Exist();
               :} switch_three
               |error  {: printError("Missing Variable token"); :}
;
switch_three ::= RPAR switch_four | error  {: printError("Missing ) token"); :} switch_four;
switch_four ::= BEGIN switch_five| error  {: printError("Missing { token"); :} switch_five;
switch_five ::= case_stms switch_six | error  {: printError("Missing { token"); :} switch_six ;
switch_six ::= DEFAULT  switch_seven ;
switch_seven ::= COLON switch_eight| error {: printError("Missing : token"); :}  switch_eight;
switch_eight ::= BREAK switch_nine | error {: printError("Missing break token"); :} ;
switch_nine ::= END | error{: printError("Missing } token"); :} ;


case_stms ::= case case_stms | case ;
case ::= CASE case_one | error  {: printError("Missing CASE token"); :} case_one ;
case_one ::= LITERAL_NUM  case_two | error  {: printError("Missing Literal_num token"); :} case_two  ;
case_two ::= COLON case_three | error  {: printError("Missing : token"); :} case_three;


case_three ::= case_content case_four | error {: printError("Missing break token"); :} case_four ;
case_four ::= BREAK | error {: printError("Missing } token"); :}  ;
case_content ::= case_structures case_content | case_structures  ;

case_structures ::= putw_struct  | puts_struct| declar_assign ;

